//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;
using RosMessageTypes.Std;

namespace RosMessageTypes.MissionManagement
{
    public class MControlPlot : Message
    {
        public const string RosMessageName = "mission_management/ControlPlot";

        public MHeader header;
        //  The car's position
        public MCone car;
        //  The orientation of the car
        public double theta;
        //  The actual cones (they are filled by the plot and not by the control package)
        public MCone[] actual_cones;
        //  The yellow cones that are known
        public MCone[] yellow_cones;
        //  The blue cones that are known
        public MCone[] blue_cones;
        //  The orange cones that are known
        public MCone[] orange_cones;
        //  The covariance matrix
        public MFloatArray[] p_covariance;
        //  The middle points of the ppc
        public MCone[] middle_points;
        //  The target point of the ppc
        public MCone target_point;

        public MControlPlot()
        {
            this.header = new MHeader();
            this.car = new MCone();
            this.theta = 0.0;
            this.actual_cones = new MCone[0];
            this.yellow_cones = new MCone[0];
            this.blue_cones = new MCone[0];
            this.orange_cones = new MCone[0];
            this.p_covariance = new MFloatArray[0];
            this.middle_points = new MCone[0];
            this.target_point = new MCone();
        }

        public MControlPlot(MHeader header, MCone car, double theta, MCone[] actual_cones, MCone[] yellow_cones, MCone[] blue_cones, MCone[] orange_cones, MFloatArray[] p_covariance, MCone[] middle_points, MCone target_point)
        {
            this.header = header;
            this.car = car;
            this.theta = theta;
            this.actual_cones = actual_cones;
            this.yellow_cones = yellow_cones;
            this.blue_cones = blue_cones;
            this.orange_cones = orange_cones;
            this.p_covariance = p_covariance;
            this.middle_points = middle_points;
            this.target_point = target_point;
        }
        public override List<byte[]> SerializationStatements()
        {
            var listOfSerializations = new List<byte[]>();
            listOfSerializations.AddRange(header.SerializationStatements());
            listOfSerializations.AddRange(car.SerializationStatements());
            listOfSerializations.Add(BitConverter.GetBytes(this.theta));
            
            listOfSerializations.Add(BitConverter.GetBytes(actual_cones.Length));
            foreach(var entry in actual_cones)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(yellow_cones.Length));
            foreach(var entry in yellow_cones)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(blue_cones.Length));
            foreach(var entry in blue_cones)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(orange_cones.Length));
            foreach(var entry in orange_cones)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(p_covariance.Length));
            foreach(var entry in p_covariance)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(middle_points.Length));
            foreach(var entry in middle_points)
                listOfSerializations.Add(entry.Serialize());
            listOfSerializations.AddRange(target_point.SerializationStatements());

            return listOfSerializations;
        }

        public override int Deserialize(byte[] data, int offset)
        {
            offset = this.header.Deserialize(data, offset);
            offset = this.car.Deserialize(data, offset);
            this.theta = BitConverter.ToDouble(data, offset);
            offset += 8;
            
            var actual_conesArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.actual_cones= new MCone[actual_conesArrayLength];
            for(var i = 0; i < actual_conesArrayLength; i++)
            {
                this.actual_cones[i] = new MCone();
                offset = this.actual_cones[i].Deserialize(data, offset);
            }
            
            var yellow_conesArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.yellow_cones= new MCone[yellow_conesArrayLength];
            for(var i = 0; i < yellow_conesArrayLength; i++)
            {
                this.yellow_cones[i] = new MCone();
                offset = this.yellow_cones[i].Deserialize(data, offset);
            }
            
            var blue_conesArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.blue_cones= new MCone[blue_conesArrayLength];
            for(var i = 0; i < blue_conesArrayLength; i++)
            {
                this.blue_cones[i] = new MCone();
                offset = this.blue_cones[i].Deserialize(data, offset);
            }
            
            var orange_conesArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.orange_cones= new MCone[orange_conesArrayLength];
            for(var i = 0; i < orange_conesArrayLength; i++)
            {
                this.orange_cones[i] = new MCone();
                offset = this.orange_cones[i].Deserialize(data, offset);
            }
            
            var p_covarianceArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.p_covariance= new MFloatArray[p_covarianceArrayLength];
            for(var i = 0; i < p_covarianceArrayLength; i++)
            {
                this.p_covariance[i] = new MFloatArray();
                offset = this.p_covariance[i].Deserialize(data, offset);
            }
            
            var middle_pointsArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.middle_points= new MCone[middle_pointsArrayLength];
            for(var i = 0; i < middle_pointsArrayLength; i++)
            {
                this.middle_points[i] = new MCone();
                offset = this.middle_points[i].Deserialize(data, offset);
            }
            offset = this.target_point.Deserialize(data, offset);

            return offset;
        }

        public override string ToString()
        {
            return "MControlPlot: " +
            "\nheader: " + header.ToString() +
            "\ncar: " + car.ToString() +
            "\ntheta: " + theta.ToString() +
            "\nactual_cones: " + System.String.Join(", ", actual_cones.ToList()) +
            "\nyellow_cones: " + System.String.Join(", ", yellow_cones.ToList()) +
            "\nblue_cones: " + System.String.Join(", ", blue_cones.ToList()) +
            "\norange_cones: " + System.String.Join(", ", orange_cones.ToList()) +
            "\np_covariance: " + System.String.Join(", ", p_covariance.ToList()) +
            "\nmiddle_points: " + System.String.Join(", ", middle_points.ToList()) +
            "\ntarget_point: " + target_point.ToString();
        }
    }
}
